// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
)

const search = `-- name: Search :many
SELECT DISTINCT
    o.id AS object_id,
    o.object_type_id AS object_type_id,
    d.id AS door_id,
    CONCAT(o.name, ' (', f.name, ')') AS preview
FROM
    objects o
    JOIN floors f ON f.id = o.floor_id
    JOIN buildings b ON b.id = f.building_id
    JOIN doors d ON d.object_id = o.id
    JOIN connections c ON (
        c.from_id = d.id
        OR c.to_id = d.id
    )
WHERE
    b.id = $1
    AND (
        $2 = ''
        OR o.name ILIKE '%' || $2 || '%'
        OR o.alias ILIKE '%' || $2 || '%'
        OR o.description ILIKE '%' || $2 || '%'
    )
ORDER BY preview, o.id
`

type SearchParams struct {
	ID      uuid.UUID
	Column2 interface{}
}

type SearchRow struct {
	ObjectID     uuid.UUID
	ObjectTypeID int32
	DoorID       uuid.UUID
	Preview      interface{}
}

func (q *Queries) Search(ctx context.Context, arg SearchParams) ([]SearchRow, error) {
	rows, err := q.db.QueryContext(ctx, search, arg.ID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchRow
	for rows.Next() {
		var i SearchRow
		if err := rows.Scan(
			&i.ObjectID,
			&i.ObjectTypeID,
			&i.DoorID,
			&i.Preview,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
