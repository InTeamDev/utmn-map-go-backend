// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package sqlc

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createBuilding = `-- name: CreateBuilding :one
INSERT INTO buildings (id, name, address)
VALUES ($1, $2, $3)
RETURNING id, name, address
`

type CreateBuildingParams struct {
	ID      uuid.UUID
	Name    string
	Address string
}

func (q *Queries) CreateBuilding(ctx context.Context, arg CreateBuildingParams) (Building, error) {
	row := q.db.QueryRowContext(ctx, createBuilding, arg.ID, arg.Name, arg.Address)
	var i Building
	err := row.Scan(&i.ID, &i.Name, &i.Address)
	return i, err
}

const deleteBuilding = `-- name: DeleteBuilding :exec
DELETE FROM buildings
WHERE id = $1
`

func (q *Queries) DeleteBuilding(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteBuilding, id)
	return err
}

const getBuildingByID = `-- name: GetBuildingByID :one
SELECT 
    b.id, 
    b.name,
    b.address
FROM buildings b
WHERE b.id = $1::uuid
`

func (q *Queries) GetBuildingByID(ctx context.Context, id uuid.UUID) (Building, error) {
	row := q.db.QueryRowContext(ctx, getBuildingByID, id)
	var i Building
	err := row.Scan(&i.ID, &i.Name, &i.Address)
	return i, err
}

const getBuildings = `-- name: GetBuildings :many
SELECT 
    b.id, 
    b.name,
    b.address
FROM buildings b
`

func (q *Queries) GetBuildings(ctx context.Context) ([]Building, error) {
	rows, err := q.db.QueryContext(ctx, getBuildings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Building
	for rows.Next() {
		var i Building
		if err := rows.Scan(&i.ID, &i.Name, &i.Address); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDoorsByObjectIDs = `-- name: GetDoorsByObjectIDs :many
SELECT 
    d.id, 
    d.x, 
    d.y, 
    d.width, 
    d.height, 
    od.object_id
FROM doors d
JOIN object_doors od ON d.id = od.door_id
WHERE od.object_id = ANY($1::uuid[])
`

type GetDoorsByObjectIDsRow struct {
	ID       uuid.UUID
	X        float64
	Y        float64
	Width    float64
	Height   float64
	ObjectID uuid.UUID
}

func (q *Queries) GetDoorsByObjectIDs(ctx context.Context, objectIds []uuid.UUID) ([]GetDoorsByObjectIDsRow, error) {
	rows, err := q.db.QueryContext(ctx, getDoorsByObjectIDs, pq.Array(objectIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDoorsByObjectIDsRow
	for rows.Next() {
		var i GetDoorsByObjectIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.X,
			&i.Y,
			&i.Width,
			&i.Height,
			&i.ObjectID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFloorBackground = `-- name: GetFloorBackground :many
SELECT 
    fp.id, 
    fp.label, 
    fp.z_index, 
    json_agg(
        json_build_object(
            'order', fpp.point_order,
            'x', fpp.x,
            'y', fpp.y
        ) ORDER BY fpp.point_order
    ) AS points
FROM floor_polygons fp
JOIN floor_polygon_points fpp ON fp.id = fpp.polygon_id
WHERE fp.floor_id = $1::uuid
GROUP BY fp.id, fp.label, fp.z_index
ORDER BY fp.z_index
`

type GetFloorBackgroundRow struct {
	ID     uuid.UUID
	Label  sql.NullString
	ZIndex sql.NullInt32
	Points json.RawMessage
}

func (q *Queries) GetFloorBackground(ctx context.Context, floorID uuid.UUID) ([]GetFloorBackgroundRow, error) {
	rows, err := q.db.QueryContext(ctx, getFloorBackground, floorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFloorBackgroundRow
	for rows.Next() {
		var i GetFloorBackgroundRow
		if err := rows.Scan(
			&i.ID,
			&i.Label,
			&i.ZIndex,
			&i.Points,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFloorByID = `-- name: GetFloorByID :one
SELECT id, name, alias, building_id FROM floors
WHERE id = $1::uuid
`

func (q *Queries) GetFloorByID(ctx context.Context, id uuid.UUID) (Floor, error) {
	row := q.db.QueryRowContext(ctx, getFloorByID, id)
	var i Floor
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Alias,
		&i.BuildingID,
	)
	return i, err
}

const getFloorsByBuilding = `-- name: GetFloorsByBuilding :many
SELECT 
    f.id, 
    f.name,
    f.alias,
    f.building_id
FROM floors f 
WHERE f.building_id = $1::uuid
`

func (q *Queries) GetFloorsByBuilding(ctx context.Context, buildingID uuid.UUID) ([]Floor, error) {
	rows, err := q.db.QueryContext(ctx, getFloorsByBuilding, buildingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Floor
	for rows.Next() {
		var i Floor
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Alias,
			&i.BuildingID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getObjectTypeByID = `-- name: GetObjectTypeByID :one
SELECT id, name, alias FROM object_types
WHERE id = $1::int
`

func (q *Queries) GetObjectTypeByID(ctx context.Context, id int32) (ObjectType, error) {
	row := q.db.QueryRowContext(ctx, getObjectTypeByID, id)
	var i ObjectType
	err := row.Scan(&i.ID, &i.Name, &i.Alias)
	return i, err
}

const getObjectTypeByName = `-- name: GetObjectTypeByName :one
SELECT id, name, alias FROM object_types
WHERE name = $1::VARCHAR(50)
`

func (q *Queries) GetObjectTypeByName(ctx context.Context, name string) (ObjectType, error) {
	row := q.db.QueryRowContext(ctx, getObjectTypeByName, name)
	var i ObjectType
	err := row.Scan(&i.ID, &i.Name, &i.Alias)
	return i, err
}

const getObjectTypes = `-- name: GetObjectTypes :many
SELECT DISTINCT ot.id, ot.name, ot.alias
FROM object_types ot
ORDER BY ot.id
`

func (q *Queries) GetObjectTypes(ctx context.Context) ([]ObjectType, error) {
	rows, err := q.db.QueryContext(ctx, getObjectTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ObjectType
	for rows.Next() {
		var i ObjectType
		if err := rows.Scan(&i.ID, &i.Name, &i.Alias); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getObjectsByBuilding = `-- name: GetObjectsByBuilding :many
SELECT 
    o.id, 
    o.name, 
    o.alias, 
    o.description, 
    o.x, 
    o.y, 
    o.width, 
    o.height, 
    ot.id AS object_type, 
    f.id AS floor_id, 
    f.name AS floor_name, 
    b.id AS building_id, 
    b.name AS building_name
FROM objects o
JOIN floors f ON o.floor_id = f.id
JOIN buildings b ON f.building_id = b.id
JOIN object_types ot ON o.object_type_id = ot.id
WHERE b.id = $1::uuid
`

type GetObjectsByBuildingRow struct {
	ID           uuid.UUID
	Name         string
	Alias        string
	Description  sql.NullString
	X            float64
	Y            float64
	Width        float64
	Height       float64
	ObjectType   int32
	FloorID      uuid.UUID
	FloorName    string
	BuildingID   uuid.UUID
	BuildingName string
}

func (q *Queries) GetObjectsByBuilding(ctx context.Context, buildingID uuid.UUID) ([]GetObjectsByBuildingRow, error) {
	rows, err := q.db.QueryContext(ctx, getObjectsByBuilding, buildingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetObjectsByBuildingRow
	for rows.Next() {
		var i GetObjectsByBuildingRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Alias,
			&i.Description,
			&i.X,
			&i.Y,
			&i.Width,
			&i.Height,
			&i.ObjectType,
			&i.FloorID,
			&i.FloorName,
			&i.BuildingID,
			&i.BuildingName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBuilding = `-- name: UpdateBuilding :one
UPDATE buildings
SET name = COALESCE($1, name),
address = COALESCE($2, address)
WHERE id = $3::uuid
RETURNING id, name, address
`

type UpdateBuildingParams struct {
	Name    sql.NullString
	Address sql.NullString
	ID      uuid.UUID
}

func (q *Queries) UpdateBuilding(ctx context.Context, arg UpdateBuildingParams) (Building, error) {
	row := q.db.QueryRowContext(ctx, updateBuilding, arg.Name, arg.Address, arg.ID)
	var i Building
	err := row.Scan(&i.ID, &i.Name, &i.Address)
	return i, err
}

const updateObject = `-- name: UpdateObject :one
UPDATE objects
SET name = COALESCE($1, name),
    alias = COALESCE($2, alias),
    description = COALESCE($3, description),
    x = COALESCE($4, x),
    y = COALESCE($5, y),
    width = COALESCE($6, width),
    height = COALESCE($7, height),
    object_type_id = COALESCE($8, object_type_id)
WHERE id = $9
RETURNING id, name, alias, description, x, y, width, height, object_type_id, floor_id
`

type UpdateObjectParams struct {
	Name         sql.NullString
	Alias        sql.NullString
	Description  sql.NullString
	X            sql.NullFloat64
	Y            sql.NullFloat64
	Width        sql.NullFloat64
	Height       sql.NullFloat64
	ObjectTypeID sql.NullInt32
	ID           uuid.UUID
}

func (q *Queries) UpdateObject(ctx context.Context, arg UpdateObjectParams) (Object, error) {
	row := q.db.QueryRowContext(ctx, updateObject,
		arg.Name,
		arg.Alias,
		arg.Description,
		arg.X,
		arg.Y,
		arg.Width,
		arg.Height,
		arg.ObjectTypeID,
		arg.ID,
	)
	var i Object
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Alias,
		&i.Description,
		&i.X,
		&i.Y,
		&i.Width,
		&i.Height,
		&i.ObjectTypeID,
		&i.FloorID,
	)
	return i, err
}
