// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package sqlc

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createBuilding = `-- name: CreateBuilding :one
INSERT INTO buildings (id, name, address)
VALUES ($1, $2, $3)
ON CONFLICT (id) DO UPDATE SET
    name = EXCLUDED.name,
    address = EXCLUDED.address
RETURNING id, name, address
`

type CreateBuildingParams struct {
	ID      uuid.UUID
	Name    string
	Address string
}

func (q *Queries) CreateBuilding(ctx context.Context, arg CreateBuildingParams) (Building, error) {
	row := q.db.QueryRowContext(ctx, createBuilding, arg.ID, arg.Name, arg.Address)
	var i Building
	err := row.Scan(&i.ID, &i.Name, &i.Address)
	return i, err
}

const createDoor = `-- name: CreateDoor :one
INSERT INTO doors (id, x, y, width, height, object_id)
VALUES ($1::uuid, $2, $3, $4, $5, $6::uuid)
ON CONFLICT (id) DO UPDATE SET
    x = EXCLUDED.x,
    y = EXCLUDED.y,
    width = EXCLUDED.width,
    height = EXCLUDED.height,
    object_id = EXCLUDED.object_id
RETURNING id, x, y, width, height, object_id
`

type CreateDoorParams struct {
	ID       uuid.UUID
	X        float64
	Y        float64
	Width    float64
	Height   float64
	ObjectID uuid.UUID
}

func (q *Queries) CreateDoor(ctx context.Context, arg CreateDoorParams) (Door, error) {
	row := q.db.QueryRowContext(ctx, createDoor,
		arg.ID,
		arg.X,
		arg.Y,
		arg.Width,
		arg.Height,
		arg.ObjectID,
	)
	var i Door
	err := row.Scan(
		&i.ID,
		&i.X,
		&i.Y,
		&i.Width,
		&i.Height,
		&i.ObjectID,
	)
	return i, err
}

const createFloor = `-- name: CreateFloor :exec
INSERT INTO floors (id, name, alias, building_id)
VALUES ($1::uuid, $2, $3, $4::uuid)
ON CONFLICT (id) DO UPDATE SET
    name = EXCLUDED.name,
    alias = EXCLUDED.alias,
    building_id = EXCLUDED.building_id
`

type CreateFloorParams struct {
	ID         uuid.UUID
	Name       string
	Alias      string
	BuildingID uuid.UUID
}

func (q *Queries) CreateFloor(ctx context.Context, arg CreateFloorParams) error {
	_, err := q.db.ExecContext(ctx, createFloor,
		arg.ID,
		arg.Name,
		arg.Alias,
		arg.BuildingID,
	)
	return err
}

const createObject = `-- name: CreateObject :one
INSERT INTO objects (
    id,
    floor_id,
    name,
    alias,
    description,
    x,
    y,
    width,
    height,
    object_type_id
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10
)
ON CONFLICT (id) DO UPDATE SET
    name = EXCLUDED.name,
    alias = EXCLUDED.alias,
    description = EXCLUDED.description,
    x = EXCLUDED.x,
    y = EXCLUDED.y,
    width = EXCLUDED.width,
    height = EXCLUDED.height,
    object_type_id = EXCLUDED.object_type_id,
    floor_id = EXCLUDED.floor_id
RETURNING id, name, alias, description, x, y, width, height, object_type_id, floor_id
`

type CreateObjectParams struct {
	ID           uuid.UUID
	FloorID      uuid.UUID
	Name         string
	Alias        string
	Description  sql.NullString
	X            float64
	Y            float64
	Width        float64
	Height       float64
	ObjectTypeID int32
}

func (q *Queries) CreateObject(ctx context.Context, arg CreateObjectParams) (Object, error) {
	row := q.db.QueryRowContext(ctx, createObject,
		arg.ID,
		arg.FloorID,
		arg.Name,
		arg.Alias,
		arg.Description,
		arg.X,
		arg.Y,
		arg.Width,
		arg.Height,
		arg.ObjectTypeID,
	)
	var i Object
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Alias,
		&i.Description,
		&i.X,
		&i.Y,
		&i.Width,
		&i.Height,
		&i.ObjectTypeID,
		&i.FloorID,
	)
	return i, err
}

const createPolygon = `-- name: CreatePolygon :one
INSERT INTO floor_polygons (id, floor_id, label, z_index)
VALUES ($1::uuid, $2::uuid, $3, $4)
ON CONFLICT (id) DO UPDATE SET
    floor_id = EXCLUDED.floor_id,
    label = EXCLUDED.label,
    z_index = EXCLUDED.z_index
RETURNING id, floor_id, label, z_index
`

type CreatePolygonParams struct {
	ID      uuid.UUID
	FloorID uuid.UUID
	Label   sql.NullString
	ZIndex  sql.NullInt32
}

func (q *Queries) CreatePolygon(ctx context.Context, arg CreatePolygonParams) (FloorPolygon, error) {
	row := q.db.QueryRowContext(ctx, createPolygon,
		arg.ID,
		arg.FloorID,
		arg.Label,
		arg.ZIndex,
	)
	var i FloorPolygon
	err := row.Scan(
		&i.ID,
		&i.FloorID,
		&i.Label,
		&i.ZIndex,
	)
	return i, err
}

const createPolygonPoint = `-- name: CreatePolygonPoint :one
INSERT INTO floor_polygon_points (polygon_id, point_order, x, y)
VALUES ($1::uuid, $2, $3, $4)
ON CONFLICT (polygon_id, point_order) DO UPDATE SET
    x = EXCLUDED.x,
    y = EXCLUDED.y
RETURNING polygon_id, point_order, x, y
`

type CreatePolygonPointParams struct {
	PolygonID  uuid.UUID
	PointOrder int32
	X          float64
	Y          float64
}

func (q *Queries) CreatePolygonPoint(ctx context.Context, arg CreatePolygonPointParams) (FloorPolygonPoint, error) {
	row := q.db.QueryRowContext(ctx, createPolygonPoint,
		arg.PolygonID,
		arg.PointOrder,
		arg.X,
		arg.Y,
	)
	var i FloorPolygonPoint
	err := row.Scan(
		&i.PolygonID,
		&i.PointOrder,
		&i.X,
		&i.Y,
	)
	return i, err
}

const deleteBuilding = `-- name: DeleteBuilding :exec
DELETE FROM buildings
WHERE id = $1
`

func (q *Queries) DeleteBuilding(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteBuilding, id)
	return err
}

const deleteObject = `-- name: DeleteObject :exec
DELETE FROM objects
WHERE id = $1::uuid
`

func (q *Queries) DeleteObject(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteObject, id)
	return err
}

const deletePolygonPoints = `-- name: DeletePolygonPoints :exec
DELETE FROM floor_polygon_points
WHERE polygon_id = $1 AND point_order = ANY($2::int[])
`

type DeletePolygonPointsParams struct {
	PolygonID uuid.UUID
	Column2   []int32
}

func (q *Queries) DeletePolygonPoints(ctx context.Context, arg DeletePolygonPointsParams) error {
	_, err := q.db.ExecContext(ctx, deletePolygonPoints, arg.PolygonID, pq.Array(arg.Column2))
	return err
}

const getBuildingByID = `-- name: GetBuildingByID :one
SELECT 
    b.id, 
    b.name,
    b.address
FROM buildings b
WHERE b.id = $1::uuid
`

func (q *Queries) GetBuildingByID(ctx context.Context, id uuid.UUID) (Building, error) {
	row := q.db.QueryRowContext(ctx, getBuildingByID, id)
	var i Building
	err := row.Scan(&i.ID, &i.Name, &i.Address)
	return i, err
}

const getBuildings = `-- name: GetBuildings :many
SELECT 
    b.id, 
    b.name,
    b.address
FROM buildings b
`

func (q *Queries) GetBuildings(ctx context.Context) ([]Building, error) {
	rows, err := q.db.QueryContext(ctx, getBuildings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Building
	for rows.Next() {
		var i Building
		if err := rows.Scan(&i.ID, &i.Name, &i.Address); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDoor = `-- name: GetDoor :one
SELECT 
    d.id,
    d.x,
    d.y,
    d.width,
    d.height,
    d.object_id
FROM 
    doors d
WHERE 
    d.id = $1::uuid
    AND EXISTS (
        SELECT 1 FROM objects o
        JOIN floors f ON o.floor_id = f.id
        WHERE o.id = d.object_id
          AND f.building_id = $2::uuid
    )
`

type GetDoorParams struct {
	Doorid     uuid.UUID
	Buildingid uuid.UUID
}

func (q *Queries) GetDoor(ctx context.Context, arg GetDoorParams) (Door, error) {
	row := q.db.QueryRowContext(ctx, getDoor, arg.Doorid, arg.Buildingid)
	var i Door
	err := row.Scan(
		&i.ID,
		&i.X,
		&i.Y,
		&i.Width,
		&i.Height,
		&i.ObjectID,
	)
	return i, err
}

const getDoorFloorPairs = `-- name: GetDoorFloorPairs :many
SELECT
  d.id       AS door_id,
  o.floor_id AS floor_id
FROM doors d
JOIN objects o ON d.object_id = o.id
`

type GetDoorFloorPairsRow struct {
	DoorID  uuid.UUID
	FloorID uuid.UUID
}

func (q *Queries) GetDoorFloorPairs(ctx context.Context) ([]GetDoorFloorPairsRow, error) {
	rows, err := q.db.QueryContext(ctx, getDoorFloorPairs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDoorFloorPairsRow
	for rows.Next() {
		var i GetDoorFloorPairsRow
		if err := rows.Scan(&i.DoorID, &i.FloorID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDoorsByBuilding = `-- name: GetDoorsByBuilding :many
SELECT
    d.id,
    d.x,
    d.y,
    d.width,
    d.height,
    b.id AS building_id,
    o.id AS object_id
FROM doors d
JOIN objects o ON d.object_id = o.id
JOIN floors f ON f.id = o.floor_id
JOIN buildings b ON f.building_id = b.id
WHERE b.id = $1::uuid
`

type GetDoorsByBuildingRow struct {
	ID         uuid.UUID
	X          float64
	Y          float64
	Width      float64
	Height     float64
	BuildingID uuid.UUID
	ObjectID   uuid.UUID
}

func (q *Queries) GetDoorsByBuilding(ctx context.Context, buildingID uuid.UUID) ([]GetDoorsByBuildingRow, error) {
	rows, err := q.db.QueryContext(ctx, getDoorsByBuilding, buildingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDoorsByBuildingRow
	for rows.Next() {
		var i GetDoorsByBuildingRow
		if err := rows.Scan(
			&i.ID,
			&i.X,
			&i.Y,
			&i.Width,
			&i.Height,
			&i.BuildingID,
			&i.ObjectID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDoorsByObjectIDs = `-- name: GetDoorsByObjectIDs :many
SELECT 
    d.id, 
    d.x, 
    d.y, 
    d.width, 
    d.height,
    d.object_id
FROM doors d
WHERE d.object_id = ANY($1::uuid[])
`

func (q *Queries) GetDoorsByObjectIDs(ctx context.Context, objectIds []uuid.UUID) ([]Door, error) {
	rows, err := q.db.QueryContext(ctx, getDoorsByObjectIDs, pq.Array(objectIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Door
	for rows.Next() {
		var i Door
		if err := rows.Scan(
			&i.ID,
			&i.X,
			&i.Y,
			&i.Width,
			&i.Height,
			&i.ObjectID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFloorBackground = `-- name: GetFloorBackground :many
SELECT 
    fp.id, 
    fp.label, 
    fp.z_index, 
    json_agg(
        json_build_object(
            'order', fpp.point_order,
            'x', fpp.x,
            'y', fpp.y
        ) ORDER BY fpp.point_order
    ) AS points
FROM floor_polygons fp
JOIN floor_polygon_points fpp ON fp.id = fpp.polygon_id
WHERE fp.floor_id = $1::uuid
GROUP BY fp.id, fp.label, fp.z_index
ORDER BY fp.z_index
`

type GetFloorBackgroundRow struct {
	ID     uuid.UUID
	Label  sql.NullString
	ZIndex sql.NullInt32
	Points json.RawMessage
}

func (q *Queries) GetFloorBackground(ctx context.Context, floorID uuid.UUID) ([]GetFloorBackgroundRow, error) {
	rows, err := q.db.QueryContext(ctx, getFloorBackground, floorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetFloorBackgroundRow
	for rows.Next() {
		var i GetFloorBackgroundRow
		if err := rows.Scan(
			&i.ID,
			&i.Label,
			&i.ZIndex,
			&i.Points,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFloorByID = `-- name: GetFloorByID :one
SELECT id, name, alias, building_id FROM floors
WHERE id = $1::uuid
`

func (q *Queries) GetFloorByID(ctx context.Context, id uuid.UUID) (Floor, error) {
	row := q.db.QueryRowContext(ctx, getFloorByID, id)
	var i Floor
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Alias,
		&i.BuildingID,
	)
	return i, err
}

const getFloorsByBuilding = `-- name: GetFloorsByBuilding :many
SELECT 
    f.id, 
    f.name,
    f.alias,
    f.building_id
FROM floors f 
WHERE f.building_id = $1::uuid ORDER BY name asc
`

func (q *Queries) GetFloorsByBuilding(ctx context.Context, buildingID uuid.UUID) ([]Floor, error) {
	rows, err := q.db.QueryContext(ctx, getFloorsByBuilding, buildingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Floor
	for rows.Next() {
		var i Floor
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Alias,
			&i.BuildingID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getObjectByID = `-- name: GetObjectByID :one
SELECT 
    o.id, o.name, o.alias, o.description, o.x, o.y, o.width, o.height, o.object_type_id, o.floor_id, 
    f.id, f.name, f.alias, f.building_id, 
    (
        SELECT json_agg(json_build_object(
            'id', d.id,
            'x', d.x,
            'y', d.y,
            'width', d.width,
            'height', d.height
        ))
        FROM doors d
        WHERE d.object_id = o.id
    ) AS doors
FROM objects o
JOIN floors f ON o.floor_id = f.id
WHERE o.id = $1
`

type GetObjectByIDRow struct {
	ID           uuid.UUID
	Name         string
	Alias        string
	Description  sql.NullString
	X            float64
	Y            float64
	Width        float64
	Height       float64
	ObjectTypeID int32
	FloorID      uuid.UUID
	ID_2         uuid.UUID
	Name_2       string
	Alias_2      string
	BuildingID   uuid.UUID
	Doors        json.RawMessage
}

func (q *Queries) GetObjectByID(ctx context.Context, id uuid.UUID) (GetObjectByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getObjectByID, id)
	var i GetObjectByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Alias,
		&i.Description,
		&i.X,
		&i.Y,
		&i.Width,
		&i.Height,
		&i.ObjectTypeID,
		&i.FloorID,
		&i.ID_2,
		&i.Name_2,
		&i.Alias_2,
		&i.BuildingID,
		&i.Doors,
	)
	return i, err
}

const getObjectDoorPairs = `-- name: GetObjectDoorPairs :many
SELECT
  d.id AS door_id,
  o.id AS object_id
FROM doors d
JOIN objects o ON d.object_id = o.id
`

type GetObjectDoorPairsRow struct {
	DoorID   uuid.UUID
	ObjectID uuid.UUID
}

func (q *Queries) GetObjectDoorPairs(ctx context.Context) ([]GetObjectDoorPairsRow, error) {
	rows, err := q.db.QueryContext(ctx, getObjectDoorPairs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetObjectDoorPairsRow
	for rows.Next() {
		var i GetObjectDoorPairsRow
		if err := rows.Scan(&i.DoorID, &i.ObjectID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getObjectTypeByID = `-- name: GetObjectTypeByID :one
SELECT id, name, alias FROM object_types
WHERE id = $1::int
`

func (q *Queries) GetObjectTypeByID(ctx context.Context, id int32) (ObjectType, error) {
	row := q.db.QueryRowContext(ctx, getObjectTypeByID, id)
	var i ObjectType
	err := row.Scan(&i.ID, &i.Name, &i.Alias)
	return i, err
}

const getObjectTypeByName = `-- name: GetObjectTypeByName :one
SELECT id, name, alias FROM object_types
WHERE name = $1::VARCHAR(50)
`

func (q *Queries) GetObjectTypeByName(ctx context.Context, name string) (ObjectType, error) {
	row := q.db.QueryRowContext(ctx, getObjectTypeByName, name)
	var i ObjectType
	err := row.Scan(&i.ID, &i.Name, &i.Alias)
	return i, err
}

const getObjectTypes = `-- name: GetObjectTypes :many
SELECT DISTINCT ot.id, ot.name, ot.alias
FROM object_types ot
ORDER BY ot.id
`

func (q *Queries) GetObjectTypes(ctx context.Context) ([]ObjectType, error) {
	rows, err := q.db.QueryContext(ctx, getObjectTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ObjectType
	for rows.Next() {
		var i ObjectType
		if err := rows.Scan(&i.ID, &i.Name, &i.Alias); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getObjectsByBuilding = `-- name: GetObjectsByBuilding :many
SELECT 
    o.id, 
    o.name, 
    o.alias, 
    o.description, 
    o.x, 
    o.y, 
    o.width, 
    o.height, 
    ot.id AS object_type, 
    f.id AS floor_id, 
    f.name AS floor_name, 
    b.id AS building_id, 
    b.name AS building_name
FROM objects o
JOIN floors f ON o.floor_id = f.id
JOIN buildings b ON f.building_id = b.id
JOIN object_types ot ON o.object_type_id = ot.id
WHERE b.id = $1::uuid
`

type GetObjectsByBuildingRow struct {
	ID           uuid.UUID
	Name         string
	Alias        string
	Description  sql.NullString
	X            float64
	Y            float64
	Width        float64
	Height       float64
	ObjectType   int32
	FloorID      uuid.UUID
	FloorName    string
	BuildingID   uuid.UUID
	BuildingName string
}

func (q *Queries) GetObjectsByBuilding(ctx context.Context, buildingID uuid.UUID) ([]GetObjectsByBuildingRow, error) {
	rows, err := q.db.QueryContext(ctx, getObjectsByBuilding, buildingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetObjectsByBuildingRow
	for rows.Next() {
		var i GetObjectsByBuildingRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Alias,
			&i.Description,
			&i.X,
			&i.Y,
			&i.Width,
			&i.Height,
			&i.ObjectType,
			&i.FloorID,
			&i.FloorName,
			&i.BuildingID,
			&i.BuildingName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPolygonByID = `-- name: GetPolygonByID :one
SELECT id, floor_id, label, z_index
FROM floor_polygons
WHERE id = $1
`

func (q *Queries) GetPolygonByID(ctx context.Context, id uuid.UUID) (FloorPolygon, error) {
	row := q.db.QueryRowContext(ctx, getPolygonByID, id)
	var i FloorPolygon
	err := row.Scan(
		&i.ID,
		&i.FloorID,
		&i.Label,
		&i.ZIndex,
	)
	return i, err
}

const getPolygonsByFloorID = `-- name: GetPolygonsByFloorID :many
SELECT id, floor_id, label, z_index
FROM floor_polygons
WHERE floor_id = $1
`

func (q *Queries) GetPolygonsByFloorID(ctx context.Context, floorID uuid.UUID) ([]FloorPolygon, error) {
	rows, err := q.db.QueryContext(ctx, getPolygonsByFloorID, floorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FloorPolygon
	for rows.Next() {
		var i FloorPolygon
		if err := rows.Scan(
			&i.ID,
			&i.FloorID,
			&i.Label,
			&i.ZIndex,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPolygonPointsByPolygonID = `-- name: ListPolygonPointsByPolygonID :many
SELECT
  polygon_id,
  point_order AS order,
  x,
  y
FROM floor_polygon_points
WHERE polygon_id = $1
ORDER BY point_order
`

type ListPolygonPointsByPolygonIDRow struct {
	PolygonID uuid.UUID
	Order     int32
	X         float64
	Y         float64
}

func (q *Queries) ListPolygonPointsByPolygonID(ctx context.Context, polygonID uuid.UUID) ([]ListPolygonPointsByPolygonIDRow, error) {
	rows, err := q.db.QueryContext(ctx, listPolygonPointsByPolygonID, polygonID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPolygonPointsByPolygonIDRow
	for rows.Next() {
		var i ListPolygonPointsByPolygonIDRow
		if err := rows.Scan(
			&i.PolygonID,
			&i.Order,
			&i.X,
			&i.Y,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBuilding = `-- name: UpdateBuilding :one
UPDATE buildings
SET name = COALESCE($1, name),
address = COALESCE($2, address)
WHERE id = $3::uuid
RETURNING id, name, address
`

type UpdateBuildingParams struct {
	Name    sql.NullString
	Address sql.NullString
	ID      uuid.UUID
}

func (q *Queries) UpdateBuilding(ctx context.Context, arg UpdateBuildingParams) (Building, error) {
	row := q.db.QueryRowContext(ctx, updateBuilding, arg.Name, arg.Address, arg.ID)
	var i Building
	err := row.Scan(&i.ID, &i.Name, &i.Address)
	return i, err
}

const updateDoor = `-- name: UpdateDoor :one
UPDATE doors
SET 
    x = COALESCE($1, x),
    y = COALESCE($2, y),
    width = COALESCE($3, width),
    height = COALESCE($4, height),
    object_id = COALESCE($5, object_id)
WHERE 
    id = $6::uuid
    AND EXISTS (
        SELECT 1 FROM objects o
        JOIN floors f ON o.floor_id = f.id
        WHERE o.id = doors.object_id
          AND f.building_id = $7::uuid
    )
RETURNING 
    id,
    x,
    y,
    width,
    height,
    object_id
`

type UpdateDoorParams struct {
	X          float64
	Y          float64
	Width      float64
	Height     float64
	ObjectID   uuid.UUID
	DoorID     uuid.UUID
	BuildingID uuid.UUID
}

func (q *Queries) UpdateDoor(ctx context.Context, arg UpdateDoorParams) (Door, error) {
	row := q.db.QueryRowContext(ctx, updateDoor,
		arg.X,
		arg.Y,
		arg.Width,
		arg.Height,
		arg.ObjectID,
		arg.DoorID,
		arg.BuildingID,
	)
	var i Door
	err := row.Scan(
		&i.ID,
		&i.X,
		&i.Y,
		&i.Width,
		&i.Height,
		&i.ObjectID,
	)
	return i, err
}

const updateObject = `-- name: UpdateObject :one
UPDATE objects
SET name = COALESCE($1, name),
    alias = COALESCE($2, alias),
    description = COALESCE($3, description),
    x = COALESCE($4, x),
    y = COALESCE($5, y),
    width = COALESCE($6, width),
    height = COALESCE($7, height),
    object_type_id = COALESCE($8, object_type_id)
WHERE id = $9
RETURNING id, name, alias, description, x, y, width, height, object_type_id, floor_id
`

type UpdateObjectParams struct {
	Name         sql.NullString
	Alias        sql.NullString
	Description  sql.NullString
	X            sql.NullFloat64
	Y            sql.NullFloat64
	Width        sql.NullFloat64
	Height       sql.NullFloat64
	ObjectTypeID sql.NullInt32
	ID           uuid.UUID
}

func (q *Queries) UpdateObject(ctx context.Context, arg UpdateObjectParams) (Object, error) {
	row := q.db.QueryRowContext(ctx, updateObject,
		arg.Name,
		arg.Alias,
		arg.Description,
		arg.X,
		arg.Y,
		arg.Width,
		arg.Height,
		arg.ObjectTypeID,
		arg.ID,
	)
	var i Object
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Alias,
		&i.Description,
		&i.X,
		&i.Y,
		&i.Width,
		&i.Height,
		&i.ObjectTypeID,
		&i.FloorID,
	)
	return i, err
}

const updatePoligon = `-- name: UpdatePoligon :exec
UPDATE floor_polygons
SET
  label = COALESCE($1::text, label),
  z_index = COALESCE($2::int, z_index)
WHERE id = $3::uuid
`

type UpdatePoligonParams struct {
	Label  sql.NullString
	ZIndex sql.NullInt32
	ID     uuid.UUID
}

func (q *Queries) UpdatePoligon(ctx context.Context, arg UpdatePoligonParams) error {
	_, err := q.db.ExecContext(ctx, updatePoligon, arg.Label, arg.ZIndex, arg.ID)
	return err
}
