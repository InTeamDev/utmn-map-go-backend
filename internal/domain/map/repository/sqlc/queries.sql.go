// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package sqlc

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const getBuildings = `-- name: GetBuildings :many
SELECT 
    b.id, 
    b.name,
    b.address
FROM buildings b
`

func (q *Queries) GetBuildings(ctx context.Context) ([]Building, error) {
	rows, err := q.db.QueryContext(ctx, getBuildings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Building
	for rows.Next() {
		var i Building
		if err := rows.Scan(&i.ID, &i.Name, &i.Address); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDoorsByObjectIDs = `-- name: GetDoorsByObjectIDs :many
SELECT 
    d.id, 
    d.x, 
    d.y, 
    d.width, 
    d.height, 
    od.object_id
FROM doors d
JOIN object_doors od ON d.id = od.door_id
WHERE od.object_id = ANY($1::uuid[])
`

type GetDoorsByObjectIDsRow struct {
	ID       uuid.UUID
	X        float64
	Y        float64
	Width    float64
	Height   float64
	ObjectID uuid.UUID
}

func (q *Queries) GetDoorsByObjectIDs(ctx context.Context, objectIds []uuid.UUID) ([]GetDoorsByObjectIDsRow, error) {
	rows, err := q.db.QueryContext(ctx, getDoorsByObjectIDs, pq.Array(objectIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDoorsByObjectIDsRow
	for rows.Next() {
		var i GetDoorsByObjectIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.X,
			&i.Y,
			&i.Width,
			&i.Height,
			&i.ObjectID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFloorsByBuilding = `-- name: GetFloorsByBuilding :many
SELECT 
    f.id, 
    f.name,
    f.alias,
    f.building_id
FROM floors f 
WHERE f.building_id = $1::uuid
`

func (q *Queries) GetFloorsByBuilding(ctx context.Context, buildingID uuid.UUID) ([]Floor, error) {
	rows, err := q.db.QueryContext(ctx, getFloorsByBuilding, buildingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Floor
	for rows.Next() {
		var i Floor
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Alias,
			&i.BuildingID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getObjectsByBuildingAndFloor = `-- name: GetObjectsByBuildingAndFloor :many
SELECT 
    o.id, 
    o.name, 
    o.alias, 
    o.description, 
    o.x, 
    o.y, 
    o.width, 
    o.height, 
    ot.name AS object_type, 
    f.id AS floor_id, 
    f.name AS floor_name, 
    b.id AS building_id, 
    b.name AS building_name
FROM objects o
JOIN floors f ON o.floor_id = f.id
JOIN buildings b ON f.building_id = b.id
JOIN object_types ot ON o.object_type_id = ot.id
WHERE b.id = $1::uuid AND f.id = $2::uuid
`

type GetObjectsByBuildingAndFloorParams struct {
	BuildID uuid.UUID
	FloorID uuid.UUID
}

type GetObjectsByBuildingAndFloorRow struct {
	ID           uuid.UUID
	Name         string
	Alias        string
	Description  sql.NullString
	X            float64
	Y            float64
	Width        float64
	Height       float64
	ObjectType   string
	FloorID      uuid.UUID
	FloorName    string
	BuildingID   uuid.UUID
	BuildingName string
}

func (q *Queries) GetObjectsByBuildingAndFloor(ctx context.Context, arg GetObjectsByBuildingAndFloorParams) ([]GetObjectsByBuildingAndFloorRow, error) {
	rows, err := q.db.QueryContext(ctx, getObjectsByBuildingAndFloor, arg.BuildID, arg.FloorID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetObjectsByBuildingAndFloorRow
	for rows.Next() {
		var i GetObjectsByBuildingAndFloorRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Alias,
			&i.Description,
			&i.X,
			&i.Y,
			&i.Width,
			&i.Height,
			&i.ObjectType,
			&i.FloorID,
			&i.FloorName,
			&i.BuildingID,
			&i.BuildingName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getObjectsByFloor = `-- name: GetObjectsByFloor :many
SELECT 
    o.id, 
    o.name, 
    o.alias, 
    o.description, 
    o.x, 
    o.y, 
    o.width, 
    o.height, 
    ot.name AS object_type, 
    f.id AS floor_id, 
    f.name AS floor_name, 
    b.id AS building_id, 
    b.name AS building_name
FROM objects o
JOIN floors f ON o.floor_id = f.id
JOIN buildings b ON f.building_id = b.id
JOIN object_types ot ON o.object_type_id = ot.id
WHERE f.id = $1::uuid
`

type GetObjectsByFloorRow struct {
	ID           uuid.UUID
	Name         string
	Alias        string
	Description  sql.NullString
	X            float64
	Y            float64
	Width        float64
	Height       float64
	ObjectType   string
	FloorID      uuid.UUID
	FloorName    string
	BuildingID   uuid.UUID
	BuildingName string
}

func (q *Queries) GetObjectsByFloor(ctx context.Context, dollar_1 uuid.UUID) ([]GetObjectsByFloorRow, error) {
	rows, err := q.db.QueryContext(ctx, getObjectsByFloor, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetObjectsByFloorRow
	for rows.Next() {
		var i GetObjectsByFloorRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Alias,
			&i.Description,
			&i.X,
			&i.Y,
			&i.Width,
			&i.Height,
			&i.ObjectType,
			&i.FloorID,
			&i.FloorName,
			&i.BuildingID,
			&i.BuildingName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
