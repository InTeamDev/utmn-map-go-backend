// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
)

const createConnection = `-- name: CreateConnection :one
INSERT INTO connections (from_id, to_id, weight)
VALUES ($1, $2, $3)
ON CONFLICT (from_id, to_id) DO UPDATE
  SET weight = EXCLUDED.weight
RETURNING from_id, to_id, weight
`

type CreateConnectionParams struct {
	FromID uuid.UUID
	ToID   uuid.UUID
	Weight float64
}

func (q *Queries) CreateConnection(ctx context.Context, arg CreateConnectionParams) (Connection, error) {
	row := q.db.QueryRowContext(ctx, createConnection, arg.FromID, arg.ToID, arg.Weight)
	var i Connection
	err := row.Scan(&i.FromID, &i.ToID, &i.Weight)
	return i, err
}

const createIntersection = `-- name: CreateIntersection :one
INSERT INTO intersections (id, x, y, floor_id)
VALUES ($1, $2, $3, $4)
ON CONFLICT (id) DO UPDATE
  SET x = EXCLUDED.x,
      y = EXCLUDED.y,
      floor_id = EXCLUDED.floor_id
RETURNING id, x, y, floor_id
`

type CreateIntersectionParams struct {
	ID      uuid.UUID
	X       float64
	Y       float64
	FloorID uuid.UUID
}

func (q *Queries) CreateIntersection(ctx context.Context, arg CreateIntersectionParams) (Intersection, error) {
	row := q.db.QueryRowContext(ctx, createIntersection,
		arg.ID,
		arg.X,
		arg.Y,
		arg.FloorID,
	)
	var i Intersection
	err := row.Scan(
		&i.ID,
		&i.X,
		&i.Y,
		&i.FloorID,
	)
	return i, err
}

const deleteIntersection = `-- name: DeleteIntersection :exec
DELETE FROM intersections i
USING floors f, buildings b
WHERE i.id = $1
  AND i.floor_id = f.id
  AND f.building_id = b.id
  AND b.id = $2
`

type DeleteIntersectionParams struct {
	IntersectionID uuid.UUID
	BuildingID     uuid.UUID
}

func (q *Queries) DeleteIntersection(ctx context.Context, arg DeleteIntersectionParams) error {
	_, err := q.db.ExecContext(ctx, deleteIntersection, arg.IntersectionID, arg.BuildingID)
	return err
}

const deleteIntersectionConnections = `-- name: DeleteIntersectionConnections :exec
DELETE FROM connections
WHERE from_id = $1 OR to_id = $1
`

func (q *Queries) DeleteIntersectionConnections(ctx context.Context, intersectionID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteIntersectionConnections, intersectionID)
	return err
}

const getConnections = `-- name: GetConnections :many
SELECT c.from_id, c.to_id, c.weight
  FROM connections c
 WHERE EXISTS (
   -- объединяем все узлы здания: пересечения + двери
   SELECT id
     FROM (
       SELECT i.id
         FROM intersections i
         JOIN floors f ON i.floor_id = f.id
        WHERE f.building_id = $1
       UNION
       SELECT d.id
         FROM doors d
         JOIN objects o ON d.object_id = o.id
         JOIN floors f ON o.floor_id = f.id
        WHERE f.building_id = $1
     ) AS nodes
    WHERE nodes.id = c.from_id
       OR nodes.id = c.to_id
 )
`

func (q *Queries) GetConnections(ctx context.Context, buildingID uuid.UUID) ([]Connection, error) {
	rows, err := q.db.QueryContext(ctx, getConnections, buildingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Connection
	for rows.Next() {
		var i Connection
		if err := rows.Scan(&i.FromID, &i.ToID, &i.Weight); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIntersections = `-- name: GetIntersections :many
SELECT 
    i.id,
    i.x,
    i.y,
    f.id AS floor_id,
    b.id AS building_id
FROM intersections i
JOIN floors f ON i.floor_id = f.id
JOIN buildings b ON f.building_id = b.id
WHERE b.id = $1::uuid
`

type GetIntersectionsRow struct {
	ID         uuid.UUID
	X          float64
	Y          float64
	FloorID    uuid.UUID
	BuildingID uuid.UUID
}

func (q *Queries) GetIntersections(ctx context.Context, buildingID uuid.UUID) ([]GetIntersectionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getIntersections, buildingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIntersectionsRow
	for rows.Next() {
		var i GetIntersectionsRow
		if err := rows.Scan(
			&i.ID,
			&i.X,
			&i.Y,
			&i.FloorID,
			&i.BuildingID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDoorsByBuilding = `-- name: ListDoorsByBuilding :many
SELECT
    d.id        AS id,
    d.x         AS x,
    d.y         AS y,
    o.floor_id  AS floor_id
FROM doors AS d
JOIN objects AS o ON d.object_id = o.id
JOIN floors  AS f ON o.floor_id   = f.id
WHERE f.building_id = $1::uuid
`

type ListDoorsByBuildingRow struct {
	ID      uuid.UUID
	X       float64
	Y       float64
	FloorID uuid.UUID
}

func (q *Queries) ListDoorsByBuilding(ctx context.Context, dollar_1 uuid.UUID) ([]ListDoorsByBuildingRow, error) {
	rows, err := q.db.QueryContext(ctx, listDoorsByBuilding, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDoorsByBuildingRow
	for rows.Next() {
		var i ListDoorsByBuildingRow
		if err := rows.Scan(
			&i.ID,
			&i.X,
			&i.Y,
			&i.FloorID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
